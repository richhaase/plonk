# P1.3: Complex Interfaces Analysis

**Date**: 2025-07-13
**Status**: Analysis Complete

## Overview

This document analyzes the remaining complex interfaces that require careful migration due to signature differences and potential UI/UX impact.

## Remaining Interfaces

### 1. ConfigReader Interface

**Challenge**: Different return types
```go
// interfaces package
type ConfigReader interface {
    LoadConfig(configDir string) (interface{}, error)
    LoadConfigFromFile(filePath string) (interface{}, error)
    LoadConfigFromReader(reader io.Reader) (interface{}, error)
}

// config package
type ConfigReader interface {
    LoadConfig(configDir string) (*Config, error)
    LoadConfigFromFile(filePath string) (*Config, error)
    LoadConfigFromReader(reader io.Reader) (*Config, error)
}
```

**Impact Analysis**:
- Used by YAMLConfigService which implements the concrete version
- Commands use LoadConfig indirectly through config.LoadConfig function
- Mock implementations exist for testing

**Migration Options**:
1. **Option A**: Change interfaces package to use `*config.Config`
   - ❌ Creates circular dependency
   - ❌ Not viable

2. **Option B**: Keep interface{} and use type assertions
   - ✅ No breaking changes
   - ⚠️ Loses type safety
   - ⚠️ Requires runtime checks

3. **Option C**: Create a new ConfigData interface
   - ✅ Type safe
   - ✅ No circular dependency
   - ⚠️ Requires updates to all implementations

### 2. ConfigWriter Interface

**Challenge**: Different parameter order AND types
```go
// interfaces package
type ConfigWriter interface {
    SaveConfig(config interface{}, configDir string) error
    SaveConfigToFile(config interface{}, filePath string) error
    SaveConfigToWriter(config interface{}, writer io.Writer) error
}

// config package
type ConfigWriter interface {
    SaveConfig(configDir string, config *Config) error
    SaveConfigToFile(filePath string, config *Config) error
    SaveConfigToWriter(writer io.Writer, config *Config) error
}
```

**Impact Analysis**:
- Parameter order affects all callers
- Type difference (interface{} vs *Config)
- Used in config edit/save operations

### 3. ConfigValidator Interface

**Challenge**: Different validation methods
```go
// interfaces package
type ConfigValidator interface {
    ValidateConfig(config interface{}) error
    ValidateConfigFromFile(filePath string) error
}

// config package
type ConfigValidator interface {
    ValidateConfig(config *Config) error
    ValidateConfigFromReader(reader io.Reader) error
}
```

**Impact Analysis**:
- Different method sets (FromFile vs FromReader)
- Type difference in ValidateConfig parameter

### 4. ConfigService Interface

**Challenge**: Different interface composition
```go
// interfaces package
type ConfigService interface {
    ConfigReader
    ConfigWriter
    ConfigValidator
    DomainConfigLoader
}

// config package
type ConfigService interface {
    ConfigReadWriter
    DotfileConfigReader
    PackageConfigReader
    ConfigValidator
}
```

**Impact Analysis**:
- Composed of different interfaces
- ConfigReadWriter vs separate Reader/Writer
- DomainConfigLoader vs separate Dotfile/Package readers

## Risk Assessment

### High Risk Areas

1. **Type Safety Loss**: Using interface{} loses compile-time type checking
2. **Runtime Errors**: Type assertions can fail at runtime
3. **Parameter Order**: Changing order could break existing code
4. **Mock Compatibility**: Existing mocks need updates

### UI/UX Impact Points

1. **Config Loading**: Used by all commands
   - Risk: Config load failures could change error messages
   - Mitigation: Ensure error messages remain identical

2. **Config Saving**: Used by `plonk config edit`, init
   - Risk: Save failures could change behavior
   - Mitigation: Test all save scenarios

3. **Config Validation**: Used during load/save
   - Risk: Validation errors shown to users
   - Mitigation: Preserve exact error messages

## Recommended Approach

Given the **non-negotiable UI/UX constraint**, I recommend a **Phased Adapter Approach**:

### Phase 1: Create Compatibility Layer
```go
// configcompat/interfaces.go
package configcompat

import (
    "github.com/richhaase/plonk/internal/config"
    "github.com/richhaase/plonk/internal/interfaces"
)

// ConfigReaderAdapter adapts interfaces.ConfigReader to config.ConfigReader
type ConfigReaderAdapter struct {
    impl interfaces.ConfigReader
}

func (a *ConfigReaderAdapter) LoadConfig(configDir string) (*config.Config, error) {
    result, err := a.impl.LoadConfig(configDir)
    if err != nil {
        return nil, err
    }
    cfg, ok := result.(*config.Config)
    if !ok {
        return nil, errors.New("invalid config type")
    }
    return cfg, nil
}
```

### Phase 2: Update Implementations
1. YAMLConfigService implements interfaces.ConfigReader
2. Use adapters for backward compatibility
3. Test thoroughly at each step

### Phase 3: Migrate Consumers
1. Update commands to use new interfaces
2. Update mocks
3. Remove adapters once all migrated

## Testing Strategy

### Critical Test Scenarios

1. **Config Load Success**
   ```bash
   plonk config show
   plonk ls
   plonk sync
   ```

2. **Config Load Failure**
   ```bash
   rm ~/.config/plonk/plonk.yaml
   plonk config show  # Should show defaults
   ```

3. **Config Save**
   ```bash
   plonk init
   plonk config edit
   ```

4. **Config Validation**
   ```bash
   # Invalid config
   echo "invalid: [" > ~/.config/plonk/plonk.yaml
   plonk config validate
   ```

### Automated Tests
```go
// Test adapter behavior
func TestConfigReaderAdapter(t *testing.T) {
    // Test successful adaptation
    // Test type assertion failure
    // Test error propagation
}
```

## Implementation Order

1. **ConfigReader** first (most used)
2. **ConfigWriter** second
3. **ConfigValidator** third
4. **ConfigService** last (depends on others)

## Success Criteria

1. All commands work identically
2. Error messages unchanged
3. No performance degradation
4. All tests pass
5. Type safety maintained where possible

## Next Steps

1. Implement ConfigReaderAdapter
2. Test with snapshot comparison
3. Proceed if no UI/UX changes
4. Document any issues found
