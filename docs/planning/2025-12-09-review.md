# Plonk Code Review

**Date:** 2025-12-09
**Reviewer:** External Code Review
**Scope:** Full codebase review focusing on functionality, UX, maintainability, and suggested refinements

---

## Executive Summary

Plonk is a well-designed, thoughtfully-architected CLI tool for unified package and dotfile management. The configuration-driven package manager approach is elegant, the codebase follows Go best practices, and there's clear attention to UX. This review identifies areas for refinement to take the tool from good to great.

**Overall Assessment:** Strong foundation with room for polish.

---

## Strengths

| Area | Observation |
|------|-------------|
| **Architecture** | Clean separation: commands → orchestrator → resources → config. Easy to reason about. |
| **Extensibility** | YAML-driven package managers is brilliant—users can add managers without recompiling. |
| **Testing** | 90+ test files with table-driven tests, mocks, golden files, and BATS integration tests. |
| **UX Polish** | Spinners, color support, `NO_COLOR` respect, multiple output formats (table/json/yaml). |
| **Idempotency** | Pattern-based idempotent error handling ensures safe re-runs. |
| **Atomic Operations** | Lock file and dotfile writes use atomic file operations—good data safety. |

---

## Functionality Issues

### 1. Selective Apply Not Implemented

**File:** `internal/commands/apply.go:174-177`

```go
// Note: For MVP, we'll apply all dotfiles. Filtering would require significant refactoring.
// TODO: Implement selective filtering in a future iteration
output.Println("Note: Applying all dotfiles...")
```

**Impact:** Users who run `plonk apply ~/.vimrc` expect only that file to be applied. Currently applies everything with a confusing note.

**Recommendation:** Either implement filtering or remove the `[files...]` argument from the command signature to prevent user confusion.

**Priority:** Medium

---

### 2. IsInstalled Is O(n) Per Check

**File:** `internal/resources/packages/generic.go:145-158`

```go
func (g *GenericManager) IsInstalled(ctx context.Context, name string) (bool, error) {
    installed, err := g.ListInstalled(ctx)  // Calls package manager every time
    // ... linear search
}
```

**Impact:** Checking 10 packages means 10 subprocess invocations. Slow for large package lists.

**Recommendation:** Cache `ListInstalled` results with a short TTL or build a `map[string]bool` once per session.

**Priority:** Medium

---

### 3. No Retry Logic for Transient Failures

Package manager operations can fail due to network issues. There's no retry mechanism.

**Recommendation:** Add configurable retry with exponential backoff for install/upgrade operations, or at minimum surface "retry" guidance in error messages.

**Priority:** Low

---

### 4. Lock File Lacks File Locking

**File:** `internal/lock/yaml_lock.go`

Concurrent plonk invocations could corrupt the lock file. The atomic write helps, but read-modify-write cycles can still race.

**Recommendation:** Use `flock` or a `.lock` file to prevent concurrent modifications.

**Priority:** Low (edge case)

---

## UX Refinements

### 1. Confusing "Untracked" Semantics

For packages, "untracked" means "installed but not managed by plonk."
For dotfiles, "untracked" means "exists in home but not in plonk dir."

These are subtly different concepts. Users may be confused why an npm package they installed manually shows as "untracked."

**Recommendation:** Consider renaming to "external" for packages or adding clarifying text in `--help` output.

**Priority:** Low

---

### 2. Deprecated Function Still Exported

**File:** `internal/commands/helpers.go:24-30`

```go
// Deprecated: Use packages.ParsePackageSpec instead...
func ParsePackageSpec(spec string) (manager, packageName string) {
```

Exported deprecated functions clutter the API and may confuse contributors.

**Recommendation:** Remove or unexport since there's a better replacement in `packages.ParsePackageSpec`.

**Priority:** Low

---

### 3. Duplicate Helper Functions

**File:** `internal/commands/helpers.go`

```go
func GetMetadataString(...)  // Line 141 - exported
func getMetadataString(...)  // Line 190 - unexported duplicate
```

**Recommendation:** Remove the unexported duplicate.

**Priority:** Low

---

### 4. Doctor Command Could Show More Context

When a package manager isn't available, showing the install command would be more actionable:

```
✗ pnpm not found
  Install: npm install -g pnpm  OR  brew install pnpm
```

The `InstallHint` field exists in manager config but isn't always surfaced prominently in doctor output.

**Recommendation:** Ensure `InstallHint` is displayed in doctor output for missing managers.

**Priority:** Low

---

## Maintainability Issues

### 1. Type Conversion Ceremony

**File:** `internal/commands/doctor.go:83-96`

```go
func convertHealthChecks(checks []diagnostics.HealthCheck) []output.HealthCheck {
    converted := make([]output.HealthCheck, len(checks))
    for i, check := range checks {
        converted[i] = output.HealthCheck{...}  // Field-by-field copy
    }
    return converted
}
```

This pattern repeats across commands. Types like `diagnostics.HealthCheck` and `output.HealthCheck` are structurally identical.

**Recommendation:** Either embed a shared type or use type aliases to reduce boilerplate.

**Priority:** Medium (reduces maintenance burden)

---

### 2. Registry Created Multiple Times

**Files:** `helpers.go:34`, `spec.go:56`, and others

`packages.NewManagerRegistry()` is called in many places, recreating the registry each time. While not expensive, it's unnecessary repetition.

**Recommendation:** Make the registry a singleton or pass it through context/dependency injection.

**Priority:** Low

---

### 3. Mock Executor Could Be Centralized

The `MockCommandExecutor` is well-designed but defined in individual test files.

**Recommendation:** Move to `internal/testutil` for reuse across test packages.

**Priority:** Low

---

## Security Considerations

### 1. Package Name Validation (Low Risk)

**File:** `internal/resources/packages/generic.go:375-381`

```go
func (g *GenericManager) expandTemplate(cmd []string, packageName string) []string {
    result[i] = strings.ReplaceAll(part, "{{.Package}}", packageName)
}
```

The package name is validated through `ParsePackageSpec`, which only checks for empty strings. A malicious package name like `foo; rm -rf /` would be passed to the command.

**Current Mitigation:** Commands are executed via `exec.Command`, not through a shell, so shell injection is not possible. This is safe as-is.

**Recommendation:** For defense in depth, add explicit package name validation (alphanumeric, hyphens, underscores, `@`/`/` for scoped npm packages). This prevents edge cases if future code changes introduce shell execution.

**Priority:** Low (already safe due to exec.Command usage)

---

### 2. Path Traversal in Dotfiles

The dotfile system uses `filepath.Join` which normalizes `../` sequences correctly. No issues found.

---

## Minor Issues

| Location | Issue | Priority |
|----------|-------|----------|
| `main.go:39` | `setting.Value[:7]` relies on length check at line 38, but pattern is fragile | Low |
| `generic.go:74-82` | Duplicate idempotent check logic—could extract to helper | Low |
| `root.go` | No `--config-dir` flag for overriding config location via CLI (only env var) | Low |
| `README.md:28` | "Package Manager Manager™" is clever but might confuse non-native speakers | Low |

---

## Recommendations Summary

### High Priority
None identified—core functionality is solid.

### Medium Priority
1. **Fix selective apply** - Either implement or remove `[files...]` argument
2. **Cache ListInstalled results** - Improve performance for batch operations
3. **Reduce type conversion boilerplate** - Share types between packages

### Low Priority
1. Add retry logic for transient network failures
2. Add file locking for concurrent access protection
3. Clarify "untracked" terminology differences
4. Clean up deprecated/duplicate helper functions
5. Centralize mock executor for tests
6. Add explicit package name character validation

---

## Summary Grades

| Category | Grade | Notes |
|----------|-------|-------|
| **Functionality** | B+ | Core features work well; selective apply and caching gaps |
| **UX** | A- | Thoughtful output formatting; minor terminology confusion |
| **Maintainability** | B+ | Good structure; some boilerplate and duplication |
| **Security** | A- | Safe by default; could add explicit input validation |
| **Testing** | A | Comprehensive coverage; good testing patterns |
| **Documentation** | A | Excellent README and docs/ structure |

---

## Conclusion

Plonk is a mature, well-thought-out tool. The configuration-driven manager approach is genuinely innovative and differentiates it from alternatives like chezmoi and dotter. With the refinements identified above—particularly around selective apply and performance caching—it could become an excellent choice for developers who want unified package + dotfile management.

The codebase demonstrates strong engineering practices: clean architecture, comprehensive testing, and thoughtful UX. The issues identified are refinements rather than fundamental problems.
