# Plonk Configuration

This is the comprehensive guide to configuring plonk. Plonk uses two configuration files located in `~/.config/plonk/`:

## Table of Contents

- [Lock File (plonk.lock)](#lock-file-plonklock)
- [Filesystem as State](#filesystem-as-state)
- [Configuration File (plonk.yaml)](#configuration-file-plonkyaml)
- [Basic Configuration](#basic-configuration)
- [Dotfile Configuration](#dotfile-configuration)
- [Timeout Configuration](#timeout-configuration)
- [Diff Tool Configuration](#diff-tool-configuration)
- [Manager Configuration](#manager-configuration)
- [Advanced Configuration](#advanced-configuration)
- [Environment Variables](#environment-variables)
- [Configuration Precedence](#configuration-precedence)
- [Common Configuration Scenarios](#common-configuration-scenarios)

## Lock File (plonk.lock)

The lock file is automatically maintained by plonk and tracks your managed resources. Do not edit this file manually.

**Format:**

```yaml
version: 2
resources:
  - type: package
    id: brew:ripgrep
    metadata:
      manager: brew
      name: ripgrep
    installed_at: "2025-07-27T11:01:03-06:00"
  - type: package
    id: brew:fd
    metadata:
      manager: brew
      name: fd
    installed_at: "2025-07-27T11:00:51-06:00"
  - type: package
    id: npm:prettier
    metadata:
      manager: npm
      name: prettier
    installed_at: "2025-07-28T15:11:08-06:00"
  - type: package
    id: conda:numpy
    metadata:
      manager: conda
      name: numpy
    installed_at: "2025-08-09T12:30:15-06:00"
  - type: package
    id: uv:ruff
    metadata:
      manager: uv
      name: ruff
    installed_at: "2025-08-07T10:15:22-06:00"
```

**Note:** Dotfiles are not tracked in the lock file. Instead, the filesystem structure of `$PLONK_DIR` itself represents the dotfile state (see [Filesystem as State](#filesystem-as-state)).

## Filesystem as State

Plonk uses the filesystem structure of `$PLONK_DIR` to represent dotfile state. The contents of this directory define what dotfiles are managed:

```
$PLONK_DIR/
├── plonk.yaml        # Configuration (not a dotfile)
├── plonk.lock        # Package state (not a dotfile)
├── zshrc             # Deployed to ~/.zshrc
├── gitconfig         # Deployed to ~/.gitconfig
└── config/
    └── nvim/
        └── init.lua  # Deployed to ~/.config/nvim/init.lua
```

This approach provides several benefits:

- No separate tracking file needed for dotfiles
- Easy to see what's managed by examining the directory
- Git-native workflow (the directory is your repository)
- Impossible for tracking and filesystem to get out of sync

**Always Excluded**:

- `plonk.yaml` and `plonk.lock` - Configuration and package state files
- `.plonk/` directory - Reserved for future plonk metadata (templates, etc.)

## Configuration File (plonk.yaml)

User configuration file for customizing plonk behavior. This file is optional - plonk works with sensible defaults.

## Basic Configuration

### Package Manager Settings

```yaml
# Default package manager when no prefix is specified
default_manager: brew # Options: brew, npm, pnpm, cargo, pipx, conda, gem, uv

# Alternative examples:
# default_manager: npm    # Use npm for global JavaScript tools
# default_manager: cargo  # Use cargo for Rust-based CLI tools
```

## Dotfile Configuration

### Ignore Patterns

Control which files are excluded when scanning for dotfiles:

```yaml
# Note: ignore_patterns should be at the root level, not under dotfiles
ignore_patterns:
  # Temporary files
  - "*.swp"
  - "*.tmp"
  - "*.bak"
  - "*~"

  # OS-specific files
  - ".DS_Store" # macOS
  - "Thumbs.db" # Windows
  - ".Trash"

  # Cache and build directories
  - ".cache/*"
  - "node_modules/*"
  - "target/*" # Rust build output
  - "__pycache__/*" # Python cache

  # Version control
  - ".git/*"
  - ".svn/*"

  # IDE/Editor files
  - ".vscode/*"
  - ".idea/*"
  - "*.log"

# Dotfile-specific configuration (optional)
dotfiles:
  unmanaged_filters: # Filters for marking dotfiles as unmanaged
    - "*.backup"
    - "*.old"

`ignore_patterns` uses the same syntax as `.gitignore`, so you can rely on features like leading `/` for root-only matches, `**` globstars, directory-only entries with a trailing `/`, and negation with `!`. Patterns are evaluated relative to your home directory when scanning for unmanaged files and relative to the plonk config directory when reading managed dotfiles.
```

### Directory Expansion

Specify directories to recursively scan for dotfiles:

```yaml
# Note: expand_directories should be at the root level, not under dotfiles
expand_directories:
  - ".config" # Standard config location (relative to home)
  # Default is just .config, add more as needed:
  # - ".local/share"    # User data files
  # - ".ssh"            # SSH configuration
```

## Timeout Configuration

### Operation Timeouts

Control how long operations wait before timing out:

```yaml
# All timeouts in seconds
package_timeout: 180 # Package install/uninstall (3 minutes default)
operation_timeout: 300 # General operations (5 minutes default)
dotfile_timeout: 60 # Dotfile operations (1 minute default)

# Examples for different scenarios:
# Fast network, powerful machine:
# package_timeout: 120    # 2 minutes
# operation_timeout: 60   # 1 minute

# Slow network, limited resources:
# package_timeout: 600    # 10 minutes
# operation_timeout: 600  # 10 minutes
```

## Diff Tool Configuration

### Custom Diff Tool

Configure which tool is used to display differences for drifted dotfiles:

```yaml
# Default: git diff --no-index (zero-config)
diff_tool: "delta"
# Other examples:
# diff_tool: "vimdiff"              # Vim's diff mode
# diff_tool: "code --diff --wait"   # VS Code diff
# diff_tool: "meld"                 # GUI diff tool
# diff_tool: "colordiff"            # Colorized diff
```

The diff tool is executed as: `{tool} {source_path} {deployed_path}`

## Manager Configuration

Plonk v2 introduces a powerful extensibility feature: custom package manager definitions. You can define additional package managers or override built-in ones in your `plonk.yaml`.

### How Package Managers Are Defined

Package managers in plonk are defined using a YAML schema that specifies how to interact with each manager. Plonk ships a set of default manager definitions via `GetDefaultManagers` (brew, npm, pnpm, cargo, pipx, conda, gem, uv); your `plonk.yaml` can override any of these or add new ones. The effective configuration that plonk uses is:

- Defaults from `GetDefaultManagers`
- Merged with any entries you define under `managers:` in `plonk.yaml`

`plonk config show` and `plonk config edit` both display this effective configuration, including all managers.

### YAML Schema for Manager Configs (v2)

Each manager entry under `managers:` uses the same schema as `ManagerConfig` (`internal/config/managers.go`), with a few core fields you’ll typically care about:

```yaml
managers:
  manager-name:
    binary: "command"               # Required: executable binary name

    list:                           # How to list installed packages
      command: ["cmd", "args"...]   # Required: full argv for the list command
      parse: "lines"                # One of: "lines", "json", "json-map"
      json_field: "name"            # For JSON modes: which field/key to use as the package name

    install:                        # How to install a single package
      command: ["cmd", "install", "{{.Package}}"]
      idempotent_errors:
        - "already installed"

    upgrade:                        # How to upgrade a single package (optional)
      command: ["cmd", "upgrade", "{{.Package}}"]
      idempotent_errors:
        - "already up-to-date"

    upgrade_all:                    # How to upgrade all packages (optional)
      command: ["cmd", "upgrade", "--all"]
      idempotent_errors:
        - "already up-to-date"

    uninstall:                      # How to uninstall a single package
      command: ["cmd", "uninstall", "{{.Package}}"]
      idempotent_errors:
        - "not installed"

    # Optional descriptive fields used by UX surfaces like clone/doctor/help:
    description: "Human readable name"
    install_hint: "How to install this manager"
    help_url: "https://example.com/docs"
```

**Field Details (core pieces):**

- `binary`: CLI executable name for the manager (e.g., `brew`, `npm`, `uv`).
- `list.command`: argv used to list installed packages.
- `list.parse` / `list.parse_strategy`:
  - `"lines"`: each line is a package; the first token is treated as the name.
  - `"json"`: JSON array of objects; `json_field` names the string field used as the package name.
  - `"json-map"`: JSON object (optionally nested via `json_field`); keys are treated as package names.
  - `"jsonpath"`: JSONPath selectors; use `keys_from` to collect map keys and/or `values_from` to collect string values. Optional `normalize` supports `lower|none`. Invalid JSON or empty extraction on non-empty output causes an error.
- `install` / `upgrade` / `upgrade_all` / `uninstall`:
  - Each has a `command` array where `{{.Package}}` is replaced with the package name.
  - `idempotent_errors` lists substrings that should be treated as “already done” rather than failures.

More advanced features (like `name_transform` and `metadata_extractors` for npm-style scoped packages) are documented in `docs/plans/pkg-mgr-metadata-pipeline.md` and are preconfigured for the shipped managers. Most users only need to override commands or add new managers.

### How to Add Custom Managers

Add a `managers:` section to your `plonk.yaml`:

```yaml
# Example: Adding pixi as a custom manager
managers:
  pixi:
    binary: "pixi"
    list:
      command: ["pixi", "global", "list", "--json"]
      parse: "jsonpath"
      values_from: "$.packages[*].name"
      normalize: "lower"
    install:
      command: ["pixi", "global", "install", "{{.Package}}"]
      idempotent_errors:
        - "already installed"
    upgrade:
      command: ["pixi", "global", "upgrade", "{{.Package}}"]
      idempotent_errors:
        - "already up-to-date"
    upgrade_all:
      command: ["pixi", "global", "upgrade-all"]
      idempotent_errors:
        - "already up-to-date"
    uninstall:
      command: ["pixi", "global", "remove", "{{.Package}}"]
      idempotent_errors:
        - "not installed"
```

### Overriding Built-in Managers

You can also override built-in manager configurations if you need custom behavior:

```yaml
managers:
  npm:
    binary: "npm"
    list:
      command: ["npm", "list", "-g", "--depth=0", "--json"]
      parse: "jsonpath"
      keys_from: "$.dependencies"
    install:
      command: ["npm", "install", "-g", "{{.Package}}"]
      idempotent_errors:
        - "already installed"
    uninstall:
      command: ["npm", "uninstall", "-g", "{{.Package}}"]
      idempotent_errors:
        - "not installed"
```

**Note:** When overriding built-in managers, you only need to specify the fields you want to change. Any fields you omit fall back to the shipped defaults from `GetDefaultManagers`.

Because manager configs are merged field-wise:

- Providing a non-empty value overrides the default for that field.
- Omitting a field keeps the shipped default for that field.
- There is currently no way to explicitly “clear” default values (for example, to remove a default `idempotent_errors` entry or metadata extractor) via YAML alone.

For an end-to-end walkthrough (with JSONPath examples and a template you can paste), see [Adding Custom Package Managers](adding-package-managers.md).

## Advanced Configuration

### Complete Real-World Example

A comprehensive configuration for a development environment:

```yaml
# Package management
default_manager: brew

# Dotfile management
ignore_patterns:
  - "*.swp"
  - "*.tmp"
  - ".DS_Store"
  - ".cache/*"
  - "node_modules/*"
  - ".git/*"
expand_directories:
  - ".config"
  - ".local/share"

# Optional dotfile-specific configuration
dotfiles:
  unmanaged_filters:
    - "*.backup"

# Conservative timeouts for reliability
package_timeout: 600 # 10 minutes for large packages
operation_timeout: 600 # 10 minutes for searches
dotfile_timeout: 120 # 2 minutes for file operations

# Diff tool for viewing drift
diff_tool: "delta" # Use delta for syntax-highlighted diffs
```

## Environment Variables

- `PLONK_DIR` - Override config directory location (default: `~/.config/plonk`)
- `VISUAL` - Primary editor for `plonk config edit` command
- `EDITOR` - Fallback editor if VISUAL not set
- `NO_COLOR` - Disable colored output when set to any value

## Configuration Precedence

Settings are applied in the following order (highest to lowest priority):

1. **Command-line flags** - Direct flags like `--dry-run`, `--packages`
2. **Environment variables** - `PLONK_DIR`, `EDITOR`, etc.
3. **Configuration file** - Settings in `plonk.yaml`
4. **Built-in defaults** - Plonk's default values

Example: If you set `default_manager: conda` in plonk.yaml but run `plonk install brew:wget`, the `brew:` prefix overrides the configuration.

## Common Configuration Scenarios

### Scenario 1: NPM-Focused Development

For JavaScript/Node.js heavy workflows:

```yaml
default_manager: npm
package_timeout: 120 # NPM can be faster than Homebrew
operation_timeout: 180 # 3 minutes for NPM searches
```

### Scenario 2: Minimal Dotfile Management

For users who only want basic dotfile tracking:

```yaml
ignore_patterns:
  - "*" # Ignore everything by default
# Manually add only specific files with `plonk add`
```

### Scenario 3: Multi-Language Development

For polyglot developers:

```yaml
default_manager: brew # System tools via Homebrew
expand_directories:
  - ".config"
  - ".local/share"
  - ".cargo" # Rust configuration
  - ".npm" # NPM configuration
```

## Creating and Managing Configuration

```bash
# View current configuration (including defaults)
plonk config show

# Create and edit configuration file
plonk config edit

# View configuration with different output formats
plonk config show --output yaml
plonk config show --output json
```

## Viewing Configuration

The `plonk config show` command displays your effective configuration with user-defined values highlighted:

```bash
# Show configuration with (user-defined) annotations in blue
plonk config show

# Output in JSON format (clean, no annotations)
plonk config show -o json
```

This makes it easy to see at a glance which settings you've customized versus which are using defaults.

## Configuration Editing

The `plonk config edit` command provides a visudo-style editing experience:

1. **Full Runtime View**: Shows all available configuration options with their current values (defaults + your overrides)
2. **User-Defined Annotations**: Values you've customized are marked with `# (user-defined)` comments
3. **Validation Loop**: If you save invalid configuration, you'll get options to:
   - (e)dit again to fix errors
   - (r)evert changes and exit
   - (q)uit without saving
4. **Minimal Saving**: Only values that differ from defaults are written to `plonk.yaml`

This approach keeps your configuration file clean and makes it immediately clear what you've customized.

### Example Edit Session

When you run `plonk config edit`, you'll see something like:

```yaml
# Plonk Configuration Editor
# - Delete any line to revert to default
# - Only values different from defaults will be saved to plonk.yaml
# - Save and exit to apply, or exit without saving to cancel

default_manager: brew
operation_timeout: 300
package_timeout: 600 # (user-defined)
dotfile_timeout: 60

expand_directories:
  - .config
  - .ssh # (user-defined)

ignore_patterns:
  - .DS_Store
  - .Trash
  - "*.swp" # (user-defined)
```

In this example, only `package_timeout`, the additional `.ssh` entry in `expand_directories`, and the additional `*.swp` pattern in `ignore_patterns` would be saved to plonk.yaml.
