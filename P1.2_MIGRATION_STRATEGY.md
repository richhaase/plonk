# P1.2: Interface Migration Strategy

**Date**: 2025-07-13
**Status**: In Progress

## Critical Constraint

⚠️ **NON-NEGOTIABLE**: The UI/UX must remain completely unchanged. All CLI commands, outputs, behaviors, and user interactions must work exactly as they do today.

## Migration Approach

Given the UI/UX constraint, we will use a **Gradual Migration with Type Aliases** approach to ensure zero user-facing changes.

## Strategy Overview

### Phase 1: Establish Target Interfaces (No User Impact)
1. Update `/internal/interfaces/` with final interface definitions
2. Use concrete types (`*Config`) for type safety
3. Ensure all method signatures support current functionality

### Phase 2: Create Compatibility Layer (No User Impact)
1. Add type aliases in `/internal/config/interfaces.go`
2. Implement adapter methods where signatures differ
3. Maintain all existing public APIs

### Phase 3: Update Implementations (No User Impact)
1. Update internal implementations one at a time
2. Run full test suite after each change
3. Verify UI/UX remains identical

### Phase 4: Migrate Consumers (No User Impact)
1. Update import statements gradually
2. Test each component thoroughly
3. Ensure zero behavior changes

### Phase 5: Remove Legacy Code (No User Impact)
1. Remove type aliases
2. Delete adapter layers
3. Clean up old interface files

## Detailed Migration Plan

### 1. PackageConfigItem (Lowest Risk)
Since it's identical in both places, this is our test case:

```go
// Step 1: In /internal/config/interfaces.go
type PackageConfigItem = interfaces.PackageConfigItem

// Step 2: Update all references to use interfaces.PackageConfigItem
// Step 3: Remove duplicate definition
```

**Validation**: Run `plonk ls`, `plonk add`, `plonk sync` - verify identical output

### 2. ConfigReader Interface
Challenge: Different return types (`interface{}` vs `*Config`)

```go
// Current in /internal/config/interfaces.go
type ConfigReader interface {
    LoadConfig(configDir string) (*Config, error)
}

// Target in /internal/interfaces/config.go (update to):
type ConfigReader interface {
    LoadConfig(configDir string) (*config.Config, error)  // Use concrete type
}

// Migration: Add type alias
type ConfigReader = interfaces.ConfigReader
```

**Validation**:
- `plonk init` creates same config file
- `plonk config show` displays same output
- Config loading in all commands works identically

### 3. ConfigWriter Interface
Challenge: Different parameter order

```go
// Create adapter for parameter order difference
type ConfigWriterAdapter struct {
    interfaces.ConfigWriter
}

func (a *ConfigWriterAdapter) SaveConfig(configDir string, cfg *Config) error {
    return a.ConfigWriter.SaveConfig(cfg, configDir)
}
```

**Validation**:
- Config saves work exactly the same
- No changes to config file format or location

### 4. DotfileConfigLoader
Currently duplicated in multiple places:

```go
// Consolidate to single definition in interfaces
// Add type aliases in both config and state packages
// Gradually migrate consumers
```

**Validation**:
- `plonk dotfiles` shows same output
- `plonk add ~/.vimrc` works identically
- Dotfile operations unchanged

## Testing Strategy

### Automated Testing
1. **Snapshot Tests**: Capture current command outputs
2. **Integration Tests**: Full command execution paths
3. **Regression Tests**: Ensure no behavior changes

### Manual Testing Checklist
Every change must pass this checklist:

- [ ] `plonk --help` (exact same output)
- [ ] `plonk ls` (same format, same data)
- [ ] `plonk add <package>` (same behavior)
- [ ] `plonk rm <package>` (same behavior)
- [ ] `plonk sync` (same behavior)
- [ ] `plonk dotfiles` (same output)
- [ ] `plonk config show` (same format)
- [ ] Error messages unchanged
- [ ] Progress indicators unchanged
- [ ] Exit codes unchanged

### Rollback Plan
1. Each change in separate commit
2. Git tags before major changes
3. Ability to revert any step
4. Feature flags for testing (internal only)

## Implementation Order

1. **Day 1**: Set up testing infrastructure
   - Create output snapshots
   - Build regression test suite
   - Document current behaviors

2. **Day 2**: Start with PackageConfigItem
   - Lowest risk change
   - Proves the approach
   - Build confidence

3. **Day 3-4**: Core interfaces
   - ConfigReader/Writer/Validator
   - One at a time
   - Full testing between each

4. **Day 5**: State package interfaces
   - DotfileConfigLoader
   - PackageConfigLoader
   - Remove adapters

## Success Criteria

1. **Zero UI/UX changes**: Commands work exactly as before
2. **All tests pass**: No regression in functionality
3. **Performance neutral**: No slowdown in operations
4. **Code simplified**: Fewer files, no adapters

## Risk Mitigation

### High Risk Areas
1. **Command outputs**: Must remain pixel-perfect
2. **Config file handling**: Same format and location
3. **Error messages**: Must be identical

### Mitigation Strategies
1. **Output comparison tests**: Byte-for-byte comparison
2. **User acceptance testing**: Test with real workflows
3. **Gradual rollout**: One interface at a time
4. **Monitoring**: Watch for any user reports

## Next Steps

1. Implement testing infrastructure
2. Create output snapshots
3. Begin with PackageConfigItem migration
4. Monitor for any issues

The key to success is patience and thorough testing at each step. We cannot break the user experience.
