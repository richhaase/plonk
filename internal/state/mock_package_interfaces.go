// Code generated by MockGen. DO NOT EDIT.
// Source: internal/state/package_provider.go

// Package state is a generated GoMock package.
package state

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockPackageManager is a mock of PackageManager interface.
type MockPackageManager struct {
	ctrl     *gomock.Controller
	recorder *MockPackageManagerMockRecorder
}

// MockPackageManagerMockRecorder is the mock recorder for MockPackageManager.
type MockPackageManagerMockRecorder struct {
	mock *MockPackageManager
}

// NewMockPackageManager creates a new mock instance.
func NewMockPackageManager(ctrl *gomock.Controller) *MockPackageManager {
	mock := &MockPackageManager{ctrl: ctrl}
	mock.recorder = &MockPackageManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPackageManager) EXPECT() *MockPackageManagerMockRecorder {
	return m.recorder
}

// Install mocks base method.
func (m *MockPackageManager) Install(ctx context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Install", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// Install indicates an expected call of Install.
func (mr *MockPackageManagerMockRecorder) Install(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Install", reflect.TypeOf((*MockPackageManager)(nil).Install), ctx, name)
}

// IsAvailable mocks base method.
func (m *MockPackageManager) IsAvailable(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAvailable", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAvailable indicates an expected call of IsAvailable.
func (mr *MockPackageManagerMockRecorder) IsAvailable(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAvailable", reflect.TypeOf((*MockPackageManager)(nil).IsAvailable), ctx)
}

// IsInstalled mocks base method.
func (m *MockPackageManager) IsInstalled(ctx context.Context, name string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsInstalled", ctx, name)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsInstalled indicates an expected call of IsInstalled.
func (mr *MockPackageManagerMockRecorder) IsInstalled(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsInstalled", reflect.TypeOf((*MockPackageManager)(nil).IsInstalled), ctx, name)
}

// ListInstalled mocks base method.
func (m *MockPackageManager) ListInstalled(ctx context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListInstalled", ctx)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListInstalled indicates an expected call of ListInstalled.
func (mr *MockPackageManagerMockRecorder) ListInstalled(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInstalled", reflect.TypeOf((*MockPackageManager)(nil).ListInstalled), ctx)
}

// Uninstall mocks base method.
func (m *MockPackageManager) Uninstall(ctx context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Uninstall", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// Uninstall indicates an expected call of Uninstall.
func (mr *MockPackageManagerMockRecorder) Uninstall(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Uninstall", reflect.TypeOf((*MockPackageManager)(nil).Uninstall), ctx, name)
}

// MockPackageConfigLoader is a mock of PackageConfigLoader interface.
type MockPackageConfigLoader struct {
	ctrl     *gomock.Controller
	recorder *MockPackageConfigLoaderMockRecorder
}

// MockPackageConfigLoaderMockRecorder is the mock recorder for MockPackageConfigLoader.
type MockPackageConfigLoaderMockRecorder struct {
	mock *MockPackageConfigLoader
}

// NewMockPackageConfigLoader creates a new mock instance.
func NewMockPackageConfigLoader(ctrl *gomock.Controller) *MockPackageConfigLoader {
	mock := &MockPackageConfigLoader{ctrl: ctrl}
	mock.recorder = &MockPackageConfigLoaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPackageConfigLoader) EXPECT() *MockPackageConfigLoaderMockRecorder {
	return m.recorder
}

// GetPackagesForManager mocks base method.
func (m *MockPackageConfigLoader) GetPackagesForManager(managerName string) ([]PackageConfigItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPackagesForManager", managerName)
	ret0, _ := ret[0].([]PackageConfigItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPackagesForManager indicates an expected call of GetPackagesForManager.
func (mr *MockPackageConfigLoaderMockRecorder) GetPackagesForManager(managerName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPackagesForManager", reflect.TypeOf((*MockPackageConfigLoader)(nil).GetPackagesForManager), managerName)
}
